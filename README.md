Когда завершите задачу, в этом README опишите свой ход мыслей: как вы пришли к решению, какие были варианты и почему выбрали именно этот. 

# Что нужно сделать

Реализовать интерфейс с методом для проверки правил флуд-контроля. Если за последние N секунд вызовов метода Check будет больше K, значит, проверка на флуд-контроль не пройдена.

- Интерфейс FloodControl располагается в файле main.go.

- Флуд-контроль может быть запущен на нескольких экземплярах приложения одновременно, поэтому нужно предусмотреть общее хранилище данных. Допустимо использовать любое на ваше усмотрение. 

# Необязательно, но было бы круто

Хорошо, если добавите поддержку конфигурации итоговой реализации. Параметры — на ваше усмотрение.

# Ход мыслей
Сразу после прочтения задания, стало понятно, что нужно реализовать рейт-лимитер. Для хранения ключей, первым делом, в голову пришла идея использовать мапу, но ограничение на запуск нескольких экземпляров приложения одновременно подтолкнуло к мысли использовать Redis как централизованное хранилище, особенно, учитывая возможность указать время жизни (TTL) записи. Также пришла идея использовать конфиг для подключения к хранилищу и определения максимального количества запросов от одного пользователя за указанное время. Конфиг собирается из переменных окружения, которые можно установить, используя команду`source .env`
Рейт-лимитер реализован по чистой архитектуре, используя слои сервиса и стора, объявленных интерфейсами. В main функции сделано конфигурирование сервиса и небольшой тест его работы.

# Запуск
Для запуска программы можно использовать команду
`make ratelimiter-start`

Также для удобства сделаны команды 
`make redis-up`
`make redis-down`